{
  "address": "0x1efEDd5FE7776f0367dd96d83Ae8bE26dA6BE976",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_trustedSender",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "acceptTaskResults",
      "outputs": [
        {
          "components": [
            {
              "internalType": "enum ITaskAcceptorV1.Quantifier",
              "name": "quantifier",
              "type": "uint8"
            },
            {
              "internalType": "uint256[]",
              "name": "taskIds",
              "type": "uint256[]"
            }
          ],
          "internalType": "struct ITaskAcceptorV1.TaskIdSelector",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "trustedSender",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xef350fabb2e6d36816c51cffa7ba07d9fd59ba7110ab1361ac77812cd80be905",
  "receipt": {
    "to": null,
    "from": "0x3BA9F711C9808902f6a200d3715ba8a7e4D8b63f",
    "contractAddress": "0x1efEDd5FE7776f0367dd96d83Ae8bE26dA6BE976",
    "transactionIndex": 0,
    "gasUsed": "251213",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x741b9b7eac89592037ab78c207f85a9b661ba0a2b4bf87b119a6728f4f676351",
    "transactionHash": "0xef350fabb2e6d36816c51cffa7ba07d9fd59ba7110ab1361ac77812cd80be905",
    "logs": [],
    "blockNumber": 410892,
    "cumulativeGasUsed": "251213",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x7Df2e133FCFF612aA46995E82A54335F716B66be"
  ],
  "numDeployments": 9,
  "solcInputHash": "97052a36c490119665de93727d6d4f6a",
  "metadata": "{\"compiler\":{\"version\":\"0.8.18+commit.87f61d96\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_trustedSender\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"acceptTaskResults\",\"outputs\":[{\"components\":[{\"internalType\":\"enum ITaskAcceptorV1.Quantifier\",\"name\":\"quantifier\",\"type\":\"uint8\"},{\"internalType\":\"uint256[]\",\"name\":\"taskIds\",\"type\":\"uint256[]\"}],\"internalType\":\"struct ITaskAcceptorV1.TaskIdSelector\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trustedSender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"The `TrustMeBroTaskAcceptor` is the first step in fully autonomizing NFTrout. The `setTaskAcceptor` method in NFTrout allows this one to be replaced with something that checks the validity of the TEE that spawned the trout. Along with `setOwner`, these methods allow NFTrout to be owned autonomously in cooperation with TROUTDAO.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/acceptor/TrustMeBroTaskAcceptor.sol\":\"TrustMeBroTaskAcceptor\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":4294967295},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@escrin/evm/contracts/tasks/acceptor/ITaskAcceptor.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nerror UnknownQuantifier(); // yrtLPA== cabb4b3c\\n\\ninterface ITaskAcceptorV1 {\\n    struct TaskIdSelector {\\n        Quantifier quantifier;\\n        /// A sorted list identifying subset of submitted tasks that will interpereted per the quantifier.\\n        uint256[] taskIds;\\n    }\\n\\n    enum Quantifier {\\n        Unknown,\\n        All,\\n        None,\\n        Some,\\n        Excluding\\n    }\\n\\n    /// Accepts one or more elements of a task runner's task results submission, returning the seto tasks that were accepted.\\n    /// @param _taskIds a sorted set of taskIds completed in this submission\\n    /// @param _proof some proof of having completed the identiied tasks that the acceptor can verify.\\n    /// @param _report some data provided by the submitter that the requester may or may not trust\\n    function acceptTaskResults(\\n        uint256[] calldata _taskIds,\\n        bytes calldata _proof,\\n        bytes calldata _report\\n    ) external returns (TaskIdSelector memory);\\n}\\n\\n/// An extension to `ITaskAcceptorV1` that helps task runners know where to find details about how to complete the task.\\ninterface ITaskAcceptanceCriteriaV1 is ITaskAcceptorV1 {\\n    /// @return a string that could be a URI or some abi-encoded data\\n    function taskAcceptanceCriteria(uint256 _taskId) external view returns (string calldata);\\n}\\n\\nlibrary TaskIdSelectorOps {\\n    function countSelected(\\n        ITaskAcceptorV1.TaskIdSelector memory _sel,\\n        uint256 _totalCount\\n    ) internal pure returns (uint256 count) {\\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.All) return _totalCount;\\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.None) return 0;\\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.Some) return _sel.taskIds.length;\\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.Excluding)\\n            return _totalCount - _sel.taskIds.length;\\n        revert UnknownQuantifier();\\n    }\\n\\n    /// @param _set a sorted set of task ids\\n    function selected(\\n        ITaskAcceptorV1.TaskIdSelector memory _sel,\\n        uint256[] memory _set\\n    ) internal pure returns (uint256[] memory) {\\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.All) return _set;\\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.None) return new uint256[](0);\\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.Some) return _sel.taskIds;\\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.Excluding) {\\n            uint256[] memory out = new uint256[](countSelected(_sel, _set.length));\\n            uint256 selPtr;\\n            uint256 outPtr;\\n            for (uint256 setPtr; setPtr < _set.length; ++setPtr) {\\n                if (_set[setPtr] == _sel.taskIds[selPtr]) continue;\\n                out[outPtr] = _set[setPtr];\\n                selPtr++;\\n                outPtr++;\\n            }\\n            return out;\\n        }\\n        revert UnknownQuantifier();\\n    }\\n\\n    function indices(\\n        ITaskAcceptorV1.TaskIdSelector memory _sel,\\n        uint256[] memory _set\\n    ) internal pure returns (uint256[] memory) {\\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.All) {\\n            uint256[] memory ixs = new uint256[](_set.length);\\n            for (uint256 i; i < ixs.length; ++i) ixs[i] = i;\\n            return ixs;\\n        }\\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.None) return new uint256[](0);\\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.Some) {\\n            uint256[] memory ixs = new uint256[](_sel.taskIds.length);\\n            uint256 selPtr;\\n            for (uint256 setPtr; setPtr < _set.length; ++setPtr) {\\n                if (_set[setPtr] != _sel.taskIds[selPtr]) continue;\\n                ixs[selPtr] = setPtr;\\n                selPtr++;\\n            }\\n            return ixs;\\n        }\\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.Excluding) {\\n            uint256[] memory ixs = new uint256[](countSelected(_sel, _set.length));\\n            uint256 selPtr;\\n            for (uint256 setPtr; setPtr < _set.length; ++setPtr) {\\n                if (_set[setPtr] == _sel.taskIds[selPtr]) continue;\\n                ixs[selPtr] = setPtr;\\n                selPtr++;\\n            }\\n            return ixs;\\n        }\\n        revert UnknownQuantifier();\\n    }\\n\\n    function pick(\\n        ITaskAcceptorV1.TaskIdSelector memory _sel,\\n        uint256[] memory _set,\\n        uint256[] memory _target\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory ixs = indices(_sel, _set);\\n        uint256[] memory placed = new uint256[](ixs.length);\\n        for (uint256 i; i < ixs.length; ++i) {\\n            placed[i] = _target[ixs[i]];\\n        }\\n        return placed;\\n    }\\n\\n    function all() internal pure returns (ITaskAcceptorV1.TaskIdSelector memory sel) {\\n        sel.quantifier = ITaskAcceptorV1.Quantifier.All;\\n    }\\n\\n    function none() internal pure returns (ITaskAcceptorV1.TaskIdSelector memory sel) {\\n        sel.quantifier = ITaskAcceptorV1.Quantifier.None;\\n    }\\n}\\n\",\"keccak256\":\"0x386386a6ba1c9a27b3af17bd666fa59d5e02dc4bb05b1f4e1d154f0e4d7495b7\",\"license\":\"MIT\"},\"contracts/acceptor/TrustMeBroTaskAcceptor.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {ITaskAcceptorV1} from \\\"@escrin/evm/contracts/tasks/acceptor/ITaskAcceptor.sol\\\";\\n\\n/// The `TrustMeBroTaskAcceptor` is the first step in fully autonomizing NFTrout.\\n/// The `setTaskAcceptor` method in NFTrout allows this one to be replaced with something that checks the validity of the TEE that spawned the trout.\\n/// Along with `setOwner`, these methods allow NFTrout to be owned autonomously in cooperation with TROUTDAO.\\ncontract TrustMeBroTaskAcceptor is ITaskAcceptorV1 {\\n    address public immutable trustedSender;\\n\\n    constructor(address _trustedSender) {\\n        trustedSender = _trustedSender;\\n    }\\n\\n    function acceptTaskResults(\\n        uint256[] calldata,\\n        bytes calldata,\\n        bytes calldata\\n    ) external virtual returns (TaskIdSelector memory) {\\n        require(msg.sender == trustedSender, \\\"not trusted sender\\\");\\n        return TaskIdSelector({\\n            quantifier: Quantifier.All,\\n            taskIds: new uint256[](0)\\n        });\\n    }\\n}\\n\",\"keccak256\":\"0x9c3c1e796161f9adfab89475c448720fe7786b1e88e9f1c655022e1d24718a85\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a03461007057601f61041538819003918201601f19168301916001600160401b038311848410176100755780849260209460405283398101031261007057516001600160a01b038116810361007057608052604051610389908161008c823960805181818160fe01526102ad0152f35b600080fd5b634e487b7160e01b600052604160045260246000fdfe608060408181526004908136101561001657600080fd5b600092833560e01c9081636927cac5146102635750639c45b66e1461003a57600080fd5b3461025f5760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261025f5767ffffffffffffffff928235848111610258573660238201121561025857808401359085821161025f57602490369260051b01011161025c57602435848111610258576100b990369085016102d1565b5050604435848111610258576100d290369085016102d1565b50506100dc610304565b818152606060208092015273ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001633036101fc57825194818601908111868210176101d0578352818552610142610304565b916001958684528284019081528451958387526060870194519060058210156101a4575092869491889482870152519580860152855180925280608086019601925b8281106101915785870386f35b8351875295810195928101928401610184565b8360216024927f4e487b7100000000000000000000000000000000000000000000000000000000835252fd5b6024836041877f4e487b7100000000000000000000000000000000000000000000000000000000835252fd5b836064918451917f08c379a0000000000000000000000000000000000000000000000000000000008352820152601260248201527f6e6f7420747275737465642073656e64657200000000000000000000000000006044820152fd5b5080fd5b80fd5b8280fd5b84903461025857817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102585760209073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b9181601f840112156102ff5782359167ffffffffffffffff83116102ff57602083818601950101116102ff57565b600080fd5b604051906040820182811067ffffffffffffffff82111761032457604052565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fdfea26469706673582212205b8e3c61884ff8044874957bb941760baa212425ef1f714f5778c45764e4019064736f6c63430008120033",
  "deployedBytecode": "0x608060408181526004908136101561001657600080fd5b600092833560e01c9081636927cac5146102635750639c45b66e1461003a57600080fd5b3461025f5760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261025f5767ffffffffffffffff928235848111610258573660238201121561025857808401359085821161025f57602490369260051b01011161025c57602435848111610258576100b990369085016102d1565b5050604435848111610258576100d290369085016102d1565b50506100dc610304565b818152606060208092015273ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001633036101fc57825194818601908111868210176101d0578352818552610142610304565b916001958684528284019081528451958387526060870194519060058210156101a4575092869491889482870152519580860152855180925280608086019601925b8281106101915785870386f35b8351875295810195928101928401610184565b8360216024927f4e487b7100000000000000000000000000000000000000000000000000000000835252fd5b6024836041877f4e487b7100000000000000000000000000000000000000000000000000000000835252fd5b836064918451917f08c379a0000000000000000000000000000000000000000000000000000000008352820152601260248201527f6e6f7420747275737465642073656e64657200000000000000000000000000006044820152fd5b5080fd5b80fd5b8280fd5b84903461025857817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102585760209073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b9181601f840112156102ff5782359167ffffffffffffffff83116102ff57602083818601950101116102ff57565b600080fd5b604051906040820182811067ffffffffffffffff82111761032457604052565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fdfea26469706673582212205b8e3c61884ff8044874957bb941760baa212425ef1f714f5778c45764e4019064736f6c63430008120033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "notice": "The `TrustMeBroTaskAcceptor` is the first step in fully autonomizing NFTrout. The `setTaskAcceptor` method in NFTrout allows this one to be replaced with something that checks the validity of the TEE that spawned the trout. Along with `setOwner`, these methods allow NFTrout to be owned autonomously in cooperation with TROUTDAO.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}