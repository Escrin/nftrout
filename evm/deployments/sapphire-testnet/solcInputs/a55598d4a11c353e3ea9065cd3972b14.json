{
  "language": "Solidity",
  "sources": {
    "@escrin/evm/contracts/tasks/acceptor/ITaskAcceptor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nerror UnknownQuantifier();\n\ninterface ITaskAcceptorV1 {\n    struct TaskIdSelector {\n        Quantifier quantifier;\n        /// A sorted list identifying subset of submitted tasks that will interpereted per the quantifier.\n        uint256[] taskIds;\n    }\n\n    enum Quantifier {\n        Unknown,\n        All,\n        None,\n        Some,\n        Excluding\n    }\n\n    /// Accepts one or more elements of a task runner's task results submission, returning the seto tasks that were accepted.\n    /// @param _taskIds a sorted set of taskIds completed in this submission\n    /// @param _proof some proof of having completed the identiied tasks that the acceptor can verify.\n    /// @param _report some data provided by the submitter that the requester may or may not trust\n    function acceptTaskResults(\n        uint256[] calldata _taskIds,\n        bytes calldata _proof,\n        bytes calldata _report\n    ) external returns (TaskIdSelector memory);\n}\n\n/// An extension to `ITaskAcceptorV1` that helps task runners know where to find details about how to complete the task.\ninterface ITaskAcceptanceCriteriaV1 is ITaskAcceptorV1 {\n    /// @return a string that could be a URI or some abi-encoded data\n    function taskAcceptanceCriteria(uint256 _taskId) external view returns (string calldata);\n}\n\nlibrary TaskIdSelectorOps {\n    function countSelected(\n        ITaskAcceptorV1.TaskIdSelector memory _sel,\n        uint256 _totalCount\n    ) internal pure returns (uint256 count) {\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.All) return _totalCount;\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.None) return 0;\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.Some) return _sel.taskIds.length;\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.Excluding)\n            return _totalCount - _sel.taskIds.length;\n        revert UnknownQuantifier();\n    }\n\n    /// @param _set a sorted set of task ids\n    function selected(\n        ITaskAcceptorV1.TaskIdSelector memory _sel,\n        uint256[] memory _set\n    ) internal pure returns (uint256[] memory) {\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.All) return _set;\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.None) return new uint256[](0);\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.Some) return _sel.taskIds;\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.Excluding) {\n            uint256[] memory out = new uint256[](countSelected(_sel, _set.length));\n            uint256 selPtr;\n            uint256 outPtr;\n            for (uint256 setPtr; setPtr < _set.length; ++setPtr) {\n                if (_set[setPtr] == _sel.taskIds[selPtr]) continue;\n                out[outPtr] = _set[setPtr];\n                selPtr++;\n                outPtr++;\n            }\n            return out;\n        }\n        revert UnknownQuantifier();\n    }\n\n    function indices(\n        ITaskAcceptorV1.TaskIdSelector memory _sel,\n        uint256[] memory _set\n    ) internal pure returns (uint256[] memory) {\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.All) {\n            uint256[] memory ixs = new uint256[](_set.length);\n            for (uint256 i; i < ixs.length; ++i) ixs[i] = i;\n            return ixs;\n        }\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.None) return new uint256[](0);\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.Some) {\n            uint256[] memory ixs = new uint256[](_sel.taskIds.length);\n            uint256 selPtr;\n            for (uint256 setPtr; setPtr < _set.length; ++setPtr) {\n                if (_set[setPtr] != _sel.taskIds[selPtr]) continue;\n                ixs[selPtr] = setPtr;\n                selPtr++;\n            }\n            return ixs;\n        }\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.Excluding) {\n            uint256[] memory ixs = new uint256[](countSelected(_sel, _set.length));\n            uint256 selPtr;\n            for (uint256 setPtr; setPtr < _set.length; ++setPtr) {\n                if (_set[setPtr] == _sel.taskIds[selPtr]) continue;\n                ixs[selPtr] = setPtr;\n                selPtr++;\n            }\n            return ixs;\n        }\n        revert UnknownQuantifier();\n    }\n\n    function pick(\n        ITaskAcceptorV1.TaskIdSelector memory _sel,\n        uint256[] memory _set,\n        uint256[] memory _target\n    ) internal pure returns (uint256[] memory) {\n        uint256[] memory ixs = indices(_sel, _set);\n        uint256[] memory placed = new uint256[](ixs.length);\n        for (uint256 i; i < ixs.length; ++i) {\n            placed[i] = _target[ixs[i]];\n        }\n        return placed;\n    }\n\n    function all() internal pure returns (ITaskAcceptorV1.TaskIdSelector memory sel) {\n        sel.quantifier = ITaskAcceptorV1.Quantifier.All;\n    }\n\n    function none() internal pure returns (ITaskAcceptorV1.TaskIdSelector memory sel) {\n        sel.quantifier = ITaskAcceptorV1.Quantifier.None;\n    }\n}\n"
    },
    "@escrin/evm/contracts/tasks/acceptor/TaskAcceptor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {ITaskAcceptorV1, TaskIdSelectorOps} from \"./ITaskAcceptor.sol\";\n\n/// The input task ids were not sorted.\nerror SubmisionTaskIdsNotSorted();\n/// The set of accepted task ids was not sorted.\nerror AcceptedTaskIdsNotSorted();\n\nabstract contract TaskAcceptorV1 is ITaskAcceptorV1 {\n    using TaskIdSelectorOps for TaskIdSelector;\n\n    function acceptTaskResults(\n        uint256[] calldata _taskIds,\n        bytes calldata _proof,\n        bytes calldata _report\n    ) external virtual returns (TaskIdSelector memory sel) {\n        if (!_isSortedSet(_taskIds)) revert SubmisionTaskIdsNotSorted();\n        _beforeTaskResultsAccepted(_taskIds, _proof, _report, msg.sender);\n        sel = _acceptTaskResults(_taskIds, _proof, _report, msg.sender);\n        if (!_isSortedSet(sel.taskIds)) revert AcceptedTaskIdsNotSorted();\n        _afterTaskResultsAccepted(_taskIds, _report, msg.sender, sel);\n    }\n\n    /// Accepts one or more elements of a task runner's task results submission, returning the seto tasks that were accepted.\n    /// @param _taskIds a sorted set of taskIds completed in this submission\n    /// @param _proof some proof of having completed the identiied tasks that the acceptor can verify.\n    /// @param _report Some data provided by the submitter that the requester may or may not trust\n    /// @param _submitter The account that submitted the task results.\n    /// @return A selection of the accepted task results, which may be empty.\n    function _acceptTaskResults(\n        uint256[] calldata _taskIds,\n        bytes calldata _proof,\n        bytes calldata _report,\n        address _submitter\n    ) internal virtual returns (TaskIdSelector memory);\n\n    /// Runs before tasks are accepted.\n    function _beforeTaskResultsAccepted(\n        uint256[] calldata /* _taskIds */,\n        bytes calldata /* _proof */,\n        bytes calldata /* _report */,\n        address /* _submitter */\n    ) internal virtual {\n        return;\n    }\n\n    function _afterTaskResultsAccepted(\n        uint256[] calldata /* _taskIds */,\n        bytes calldata /* _report */,\n        address /* _submitter */,\n        TaskIdSelector memory /* _selected */\n    ) internal virtual {\n        return;\n    }\n\n    function _isSortedSet(uint256[] memory _input) internal pure returns (bool) {\n        for (uint256 i = 1; i < _input.length; ++i) {\n            if (_input[i] <= _input[i - 1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"
    },
    "@escrin/evm/contracts/tasks/acceptor/TrustedSenderTaskAcceptor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {TaskAcceptorV1} from \"./TaskAcceptor.sol\";\n\nabstract contract TrustedSenderTaskAcceptorV1 is TaskAcceptorV1 {\n    address public immutable trustedSender;\n\n    constructor(address _trustedSender) {\n        trustedSender = _trustedSender;\n    }\n\n    function _acceptTaskResults(\n        uint256[] calldata,\n        bytes calldata,\n        bytes calldata,\n        address _submitter\n    ) internal virtual override returns (TaskIdSelector memory sel) {\n        sel.quantifier = _isTrustedSender(_submitter) ? Quantifier.All : Quantifier.None;\n    }\n\n    function _isTrustedSender(address addr) internal virtual view returns (bool) {\n        return addr == trustedSender;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/acceptor/TrustMeBroTaskAcceptor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {TrustedSenderTaskAcceptorV1} from \"@escrin/evm/contracts/tasks/acceptor/TrustedSenderTaskAcceptor.sol\";\n\n/// The `TrustMeBroTaskAcceptor` is the first step in fully autonomizing NFTrout.\n/// The `setTaskAcceptor` method in NFTrout allows this one to be replaced with something that checks the validity of the TEE that spawned the trout.\n/// Along with `setOwner`, these methods allow NFTrout to be owned autonomously in cooperation with TROUTDAO.\ncontract TrustMeBroTaskAcceptor is TrustedSenderTaskAcceptorV1 {\n    constructor(address _trustedSender) TrustedSenderTaskAcceptorV1(_trustedSender) {\n        return;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}