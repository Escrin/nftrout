{
  "address": "0x49f3615caaf3b3a64c395dd359fd0a25a08c7233",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "acceptTaskResults",
      "outputs": [
        {
          "components": [
            {
              "internalType": "enum ITaskAcceptorV1.Quantifier",
              "name": "quantifier",
              "type": "uint8"
            },
            {
              "internalType": "uint256[]",
              "name": "taskIds",
              "type": "uint256[]"
            }
          ],
          "internalType": "struct ITaskAcceptorV1.TaskIdSelector",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x78e7089c33cda0deec3dcbebde6b4a0c80c7f7562cc47ce517f9b2868e9081e8",
  "receipt": {
    "to": null,
    "from": "0x3ba9f711c9808902f6a200d3715ba8a7e4d8b63f",
    "contractAddress": "0x49f3615caaf3b3a64c395dd359fd0a25a08c7233",
    "transactionIndex": "0x8e",
    "gasUsed": "0x35aa287",
    "logsBloom": "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
    "blockHash": "0x99c480e346d23a10f37678320429f36eb091f1c78775e6de6476ba6394a26d7e",
    "transactionHash": "0x78e7089c33cda0deec3dcbebde6b4a0c80c7f7562cc47ce517f9b2868e9081e8",
    "logs": [],
    "blockNumber": "0x2b3d4a",
    "cumulativeGasUsed": "0x0",
    "status": "0x1"
  },
  "args": [],
  "numDeployments": 3,
  "solcInputHash": "b1f4cd2bc617f984cdac3ef25dc0cab5",
  "metadata": "{\"compiler\":{\"version\":\"0.8.18+commit.87f61d96\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"acceptTaskResults\",\"outputs\":[{\"components\":[{\"internalType\":\"enum ITaskAcceptorV1.Quantifier\",\"name\":\"quantifier\",\"type\":\"uint8\"},{\"internalType\":\"uint256[]\",\"name\":\"taskIds\",\"type\":\"uint256[]\"}],\"internalType\":\"struct ITaskAcceptorV1.TaskIdSelector\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"The `TrustMeBroTaskAcceptor` is the first step in fully autonomizing NFTrout. The `setTaskAcceptor` method in NFTrout allows this one to be replaced with something that checks the validity of the TEE that spawned the trout. Along with `setOwner`, these methods allow NFTrout to be owned autonomously in cooperation with TROUTDAO.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/acceptor/TrustMeBroTaskAcceptor.sol\":\"TrustMeBroTaskAcceptor\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":4294967295},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@escrin/evm/contracts/tasks/acceptor/ITaskAcceptor.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nerror UnknownQuantifier(); // yrtLPA== cabb4b3c\\n\\ninterface ITaskAcceptorV1 {\\n    struct TaskIdSelector {\\n        Quantifier quantifier;\\n        /// A sorted list identifying subset of submitted tasks that will interpereted per the quantifier.\\n        uint256[] taskIds;\\n    }\\n\\n    enum Quantifier {\\n        Unknown,\\n        All,\\n        None,\\n        Some,\\n        Excluding\\n    }\\n\\n    /// Accepts one or more elements of a task runner's task results submission, returning the seto tasks that were accepted.\\n    /// @param _taskIds a sorted set of taskIds completed in this submission\\n    /// @param _proof some proof of having completed the identiied tasks that the acceptor can verify.\\n    /// @param _report some data provided by the submitter that the requester may or may not trust\\n    function acceptTaskResults(\\n        uint256[] calldata _taskIds,\\n        bytes calldata _proof,\\n        bytes calldata _report\\n    ) external returns (TaskIdSelector memory);\\n}\\n\\n/// An extension to `ITaskAcceptorV1` that helps task runners know where to find details about how to complete the task.\\ninterface ITaskAcceptanceCriteriaV1 is ITaskAcceptorV1 {\\n    /// @return a string that could be a URI or some abi-encoded data\\n    function taskAcceptanceCriteria(uint256 _taskId) external view returns (string calldata);\\n}\\n\\nlibrary TaskIdSelectorOps {\\n    function countSelected(\\n        ITaskAcceptorV1.TaskIdSelector memory _sel,\\n        uint256 _totalCount\\n    ) internal pure returns (uint256 count) {\\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.All) return _totalCount;\\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.None) return 0;\\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.Some) return _sel.taskIds.length;\\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.Excluding)\\n            return _totalCount - _sel.taskIds.length;\\n        revert UnknownQuantifier();\\n    }\\n\\n    /// @param _set a sorted set of task ids\\n    function selected(\\n        ITaskAcceptorV1.TaskIdSelector memory _sel,\\n        uint256[] memory _set\\n    ) internal pure returns (uint256[] memory) {\\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.All) return _set;\\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.None) return new uint256[](0);\\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.Some) return _sel.taskIds;\\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.Excluding) {\\n            uint256[] memory out = new uint256[](countSelected(_sel, _set.length));\\n            uint256 selPtr;\\n            uint256 outPtr;\\n            for (uint256 setPtr; setPtr < _set.length; ++setPtr) {\\n                if (_set[setPtr] == _sel.taskIds[selPtr]) continue;\\n                out[outPtr] = _set[setPtr];\\n                selPtr++;\\n                outPtr++;\\n            }\\n            return out;\\n        }\\n        revert UnknownQuantifier();\\n    }\\n\\n    function indices(\\n        ITaskAcceptorV1.TaskIdSelector memory _sel,\\n        uint256[] memory _set\\n    ) internal pure returns (uint256[] memory) {\\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.All) {\\n            uint256[] memory ixs = new uint256[](_set.length);\\n            for (uint256 i; i < ixs.length; ++i) ixs[i] = i;\\n            return ixs;\\n        }\\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.None) return new uint256[](0);\\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.Some) {\\n            uint256[] memory ixs = new uint256[](_sel.taskIds.length);\\n            uint256 selPtr;\\n            for (uint256 setPtr; setPtr < _set.length; ++setPtr) {\\n                if (_set[setPtr] != _sel.taskIds[selPtr]) continue;\\n                ixs[selPtr] = setPtr;\\n                selPtr++;\\n            }\\n            return ixs;\\n        }\\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.Excluding) {\\n            uint256[] memory ixs = new uint256[](countSelected(_sel, _set.length));\\n            uint256 selPtr;\\n            for (uint256 setPtr; setPtr < _set.length; ++setPtr) {\\n                if (_set[setPtr] == _sel.taskIds[selPtr]) continue;\\n                ixs[selPtr] = setPtr;\\n                selPtr++;\\n            }\\n            return ixs;\\n        }\\n        revert UnknownQuantifier();\\n    }\\n\\n    function pick(\\n        ITaskAcceptorV1.TaskIdSelector memory _sel,\\n        uint256[] memory _set,\\n        uint256[] memory _target\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory ixs = indices(_sel, _set);\\n        uint256[] memory placed = new uint256[](ixs.length);\\n        for (uint256 i; i < ixs.length; ++i) {\\n            placed[i] = _target[ixs[i]];\\n        }\\n        return placed;\\n    }\\n\\n    function all() internal pure returns (ITaskAcceptorV1.TaskIdSelector memory sel) {\\n        sel.quantifier = ITaskAcceptorV1.Quantifier.All;\\n    }\\n\\n    function none() internal pure returns (ITaskAcceptorV1.TaskIdSelector memory sel) {\\n        sel.quantifier = ITaskAcceptorV1.Quantifier.None;\\n    }\\n}\\n\",\"keccak256\":\"0x386386a6ba1c9a27b3af17bd666fa59d5e02dc4bb05b1f4e1d154f0e4d7495b7\",\"license\":\"MIT\"},\"contracts/acceptor/TrustMeBroTaskAcceptor.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {ITaskAcceptorV1} from \\\"@escrin/evm/contracts/tasks/acceptor/ITaskAcceptor.sol\\\";\\n\\n/// The `TrustMeBroTaskAcceptor` is the first step in fully autonomizing NFTrout.\\n/// The `setTaskAcceptor` method in NFTrout allows this one to be replaced with something that checks the validity of the TEE that spawned the trout.\\n/// Along with `setOwner`, these methods allow NFTrout to be owned autonomously in cooperation with TROUTDAO.\\ncontract TrustMeBroTaskAcceptor is ITaskAcceptorV1 {\\n    function acceptTaskResults(\\n        uint256[] calldata,\\n        bytes calldata,\\n        bytes calldata\\n    ) external virtual returns (TaskIdSelector memory) {\\n        require(msg.sender == 0x7Df2e133FCFF612aA46995E82A54335F716B66be, \\\"not trusted sender\\\");\\n        return TaskIdSelector({quantifier: Quantifier.All, taskIds: new uint256[](0)});\\n    }\\n}\\n\",\"keccak256\":\"0x0ff6b9528b65dc12d2d701a456444bff58e173a030b76ad12d260ca07867cc07\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60808060405234610016576102ea908161001c8239f35b600080fdfe60406080815260048036101561001457600080fd5b600091823560e01c639c45b66e1461002b57600080fd5b3461022e5760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022e5767ffffffffffffffff928235848111610227573660238201121561022757808401359085821161022e57602490369260051b01011161022b57602435848111610227576100aa9036908501610232565b5050604435848111610227576100c39036908501610232565b50506100cd610265565b8181526060602080920152737df2e133fcff612aa46995e82a54335f716b66be33036101cb578251948186019081118682101761019f578352818552610111610265565b91600195868452828401908152845195838752606087019451906005821015610173575092869491889482870152519580860152855180925280608086019601925b8281106101605785870386f35b8351875295810195928101928401610153565b8360216024927f4e487b7100000000000000000000000000000000000000000000000000000000835252fd5b6024836041877f4e487b7100000000000000000000000000000000000000000000000000000000835252fd5b836064918451917f08c379a0000000000000000000000000000000000000000000000000000000008352820152601260248201527f6e6f7420747275737465642073656e64657200000000000000000000000000006044820152fd5b5080fd5b80fd5b8280fd5b9181601f840112156102605782359167ffffffffffffffff8311610260576020838186019501011161026057565b600080fd5b604051906040820182811067ffffffffffffffff82111761028557604052565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fdfea264697066735822122038fad5ca6fadd87532be9f313c4a4cdcda21d4b1905e7d6f052eaeb54bda2a2c64736f6c63430008120033",
  "deployedBytecode": "0x60406080815260048036101561001457600080fd5b600091823560e01c639c45b66e1461002b57600080fd5b3461022e5760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261022e5767ffffffffffffffff928235848111610227573660238201121561022757808401359085821161022e57602490369260051b01011161022b57602435848111610227576100aa9036908501610232565b5050604435848111610227576100c39036908501610232565b50506100cd610265565b8181526060602080920152737df2e133fcff612aa46995e82a54335f716b66be33036101cb578251948186019081118682101761019f578352818552610111610265565b91600195868452828401908152845195838752606087019451906005821015610173575092869491889482870152519580860152855180925280608086019601925b8281106101605785870386f35b8351875295810195928101928401610153565b8360216024927f4e487b7100000000000000000000000000000000000000000000000000000000835252fd5b6024836041877f4e487b7100000000000000000000000000000000000000000000000000000000835252fd5b836064918451917f08c379a0000000000000000000000000000000000000000000000000000000008352820152601260248201527f6e6f7420747275737465642073656e64657200000000000000000000000000006044820152fd5b5080fd5b80fd5b8280fd5b9181601f840112156102605782359167ffffffffffffffff8311610260576020838186019501011161026057565b600080fd5b604051906040820182811067ffffffffffffffff82111761028557604052565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fdfea264697066735822122038fad5ca6fadd87532be9f313c4a4cdcda21d4b1905e7d6f052eaeb54bda2a2c64736f6c63430008120033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "notice": "The `TrustMeBroTaskAcceptor` is the first step in fully autonomizing NFTrout. The `setTaskAcceptor` method in NFTrout allows this one to be replaced with something that checks the validity of the TEE that spawned the trout. Along with `setOwner`, these methods allow NFTrout to be owned autonomously in cooperation with TROUTDAO.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}